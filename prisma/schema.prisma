generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ──────────────────────────────────────────
// Users
// ──────────────────────────────────────────
model User {
  id            String    @id @default(uuid())
  phone         String?   @unique
  email         String?   @unique
  emailVerified DateTime?
  name          String?
  image         String?
  preferences    Json      @default("{}")
  userType       UserType  @default(EARLY_ACCESS)
  consentedAt    DateTime?
  consentChannel String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Invite system
  inviteCode     String?   @unique
  invitedAt      DateTime?
  revokedAt      DateTime?

  accounts Account[]
  sessions Session[]
  signals  Signal[]
  episodes Episode[]
  feedback Feedback[]
  episodeRatings EpisodeRating[]
  questionnaireResponses QuestionnaireResponse[]
  emailLogs EmailLog[]
  emailPreferences EmailPreferences?

  // Bonus episodes granted via questionnaire completion
  episodeBonusGranted Int       @default(0)

  // Last activity timestamp (signal capture, episode play, etc.) for engagement tracking
  lastActiveAt DateTime?
}

// ──────────────────────────────────────────
// NextAuth.js models
// ──────────────────────────────────────────
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ──────────────────────────────────────────
// Signals - everything the user sends in
// ──────────────────────────────────────────
model Signal {
  id        String       @id @default(uuid())
  userId    String
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  // What came in
  inputType  InputType
  channel    Channel
  rawContent String

  // Extracted data
  url            String?
  title          String?
  source         String?
  fetchedContent String?   @db.Text
  topics         String[]  @default([])

  // Processing state
  status      SignalStatus @default(QUEUED)
  processedAt DateTime?

  // Organisation
  episodeId String?
  episode   Episode?     @relation(fields: [episodeId], references: [id], onDelete: SetNull)

  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  @@index([userId, status])
  @@index([userId, createdAt])
  @@index([episodeId])
}

enum InputType {
  LINK
  TOPIC
  VOICE
  FORWARDED_EMAIL
  CLIPBOARD
}

enum Channel {
  SMS
  EMAIL
  EXTENSION
  SHARE_SHEET
  API
}

enum SignalStatus {
  PENDING
  QUEUED
  ENRICHED
  USED
  SKIPPED
  FAILED
}

// ──────────────────────────────────────────
// Episodes - the generated podcasts
// ──────────────────────────────────────────
model Episode {
  id          String        @id @default(uuid())
  userId      String
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Content
  title         String?
  script        String?       @db.Text
  summary       String?       @db.Text
  topicsCovered String[]      @default([])
  periodStart   DateTime?
  periodEnd     DateTime?

  // Audio
  audioUrl      String?
  audioDuration Int?
  voiceKey      String?

  // Generation
  status         EpisodeStatus @default(PENDING)
  generatedAt    DateTime?
  error          String?
  generationMeta Json?          // { inputTokens, outputTokens, webSearches, ttsCharacters, costs: { claude, tts, total } }
  playCount      Int            @default(0)

  // Sharing (foundation for future sharing feature)
  visibility  String         @default("private")  // private | unlisted | public
  shareToken  String?        @unique
  sharedAt    DateTime?

  // Relations
  signals     Signal[]
  segments    Segment[]
  ratings     EpisodeRating[]
  signalCount Int           @default(0)

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([userId, createdAt])
  @@index([userId, generatedAt])
  @@index([userId, status])
  @@index([status])
}

enum EpisodeStatus {
  PENDING
  SYNTHESIZING
  GENERATING
  READY
  FAILED
  ARCHIVED
}

// ──────────────────────────────────────────
// Segments - per-topic sections within an episode
// ──────────────────────────────────────────
model Segment {
  id        String   @id @default(uuid())
  episodeId String
  episode   Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  order     Int
  topic     String
  content   String   @db.Text
  sources   Json     @default("[]")

  createdAt DateTime @default(now())

  @@index([episodeId, order])
}

// ──────────────────────────────────────────
// Feedback — user feedback during early access
// ──────────────────────────────────────────
model Feedback {
  id        String         @id @default(uuid())
  userId    String
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  type      FeedbackType
  content   String         @db.Text
  status    FeedbackStatus @default(NEW)

  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@index([userId, createdAt])
  @@index([status])
}

enum UserType {
  MASTER
  EARLY_ACCESS
  TESTER
}

enum FeedbackType {
  TEXT
  VOICE
  REQUEST
}

enum FeedbackStatus {
  NEW
  REVIEWED
  RESOLVED
}

// ──────────────────────────────────────────
// Episode Ratings — per-episode user feedback
// ──────────────────────────────────────────
model EpisodeRating {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodeId String
  episode   Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  // 3 rating questions (1–5 scale)
  enjoyment   Int      // "Did you enjoy this episode?"
  resonance   Int      // "Did it resonate with you?"
  connections Int      // "Did it make useful connections?"

  // Optional follow-up (only if ratings suggest room for improvement)
  feedback    String?  @db.Text

  createdAt   DateTime @default(now())

  @@unique([userId, episodeId])
  @@index([episodeId])
}

// ──────────────────────────────────────────
// Questionnaire — early access feedback survey
// ──────────────────────────────────────────
model QuestionnaireResponse {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Responses stored as JSON: { q1: "...", q2: "...", ... }
  responses Json
  // Which milestone triggered this (e.g. 3, 6, 9)
  milestone Int

  createdAt DateTime @default(now())

  @@index([userId])
}

// ──────────────────────────────────────────
// Email Engagement — logs + preferences
// ──────────────────────────────────────────
model EmailLog {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailType   String    // invite_reminder | welcome | first_signal | first_episode | episode_ready | mid_week_nudge | quiet_week | did_you_know | curiosity_reflection | re_engage_21 | re_engage_45
  subject     String
  status      String    @default("sent")  // sent | delivered | opened | bounced
  metadata    Json?     // { episodeId, featureKey, etc. }
  createdAt   DateTime  @default(now())

  @@index([userId, emailType])
  @@index([userId, createdAt])
}

model EmailPreferences {
  id               String   @id @default(uuid())
  userId           String   @unique
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactional    Boolean  @default(true)   // episode ready, milestones
  nudges           Boolean  @default(true)   // mid-week, quiet week
  discovery        Boolean  @default(true)   // did-you-know, curiosity reflection
  reengagement     Boolean  @default(true)   // 21d, 45d
  unsubscribedAll  Boolean  @default(false)
  unsubscribeToken String   @unique @default(uuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

// ──────────────────────────────────────────
// Fixed Costs — manually entered monthly subscriptions
// ──────────────────────────────────────────
model FixedCost {
  id        String   @id @default(uuid())
  name      String                            // e.g. "Railway", "Twilio", "SendGrid"
  amount    Float                             // Monthly cost in USD
  category  String   @default("infra")        // infra, api, comms, storage, other
  notes     String?                           // Optional description
  active    Boolean  @default(true)           // Toggle without deleting

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
